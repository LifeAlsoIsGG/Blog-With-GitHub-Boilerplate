<!DOCTYPE HTML>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,LifeAlsoIsGG,Galileo,wiki" />
    <meta name="generator" content="Maverick 1.1" />
    <meta name="template" content="Kepler" />
    <link rel="alternate" type="application/rss+xml" title="LifeAlsoIsGG-Wiki &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="LifeAlsoIsGG-Wiki &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/assets/kepler-426969802d.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/assets/ExSearch/ExSearch-182e5a8868.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.10.0/dist/tocbot.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/dab9d9b8e8451c4dbdfb65a2f294612f.json"
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function(){
            if(/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)){
                document.body.classList.add('safari')
            }else{
                document.body.classList.remove('safari')
            }
        });
    </script>
    
<title>SpringMVC面试题 - LifeAlsoIsGG-Wiki</title>
<meta name="author" content="LifeAlsoIsGG" />
<meta name="description" content="1. 什么是MVC" />
<meta property="og:title" content="SpringMVC面试题 - LifeAlsoIsGG-Wiki" />
<meta property="og:description" content="1. 什么是MVC" />
<meta property="og:site_name" content="LifeAlsoIsGG-Wiki" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/archives/SpringMVC面试题/" />
<meta property="og:image" content="" />
<meta property="article:published_time" content="2020-09-15T11:40:00-00.00" />
<meta name="twitter:title" content="SpringMVC面试题 - LifeAlsoIsGG-Wiki" />
<meta name="twitter:description" content="1. 什么是MVC" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="" />


    
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//cdn.jsdelivr.net" />
<link rel="icon" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/avatar.png" type="images/x-ico" />

    </head>
    
    <body class="content">
        <header>
            <div class="container">
                <section>
                    <a href="/"><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/avatar.png">LifeAlsoIsGG-Wiki</a>
                </section>
                <section>
                    <nav>
                        <ul>
                            
                                <li><a href="https://blog.lifeisgg.online" target="_blank">Blog</a></li>
                            
                                <li><a href="https://photos.lifeisgg.online" target="_blank">Photos</a></li>
                            
                                <li><a href="https://github.com/LifeAlsoIsGG" target="_blank">GitHub</a></li>
                            
                                <li><a href="https://twitter.com/LifeAlsoIsGG" target="_blank">Twitter</a></li>
                            
                        </ul>
                    </nav>
                </section>
    
                <section>
                    <a hidden class="toggle-toc" target="_self" href="javascript:void(0)" onclick="$(body).toggleClass('toc-open')"><i class="fa fa-align-right"></i></a>
                    <a hidden class="toggle-navbar" target="_self" href="javascript:void(0)" onclick="$(body).toggleClass('navbar-open')"><i class="fa fa-indent"></i></a>
                    <button class="search-form-input"><i class="fa fa-search"></i></button>
                </section>
            </div>
        </header>

        <main>
            <div id="pjax-container" class="container">
                <aside id="navbar" class="no-scrollbar">
                    
                    <section class="sidebar-nav">
                        
                            <div class="None" ><span><a href="/">Home</a></span></div>
                        
                            <div class="None" ><span><a href="/archives/">Archives</a></span></div>
                        
                            <div class="None" ><span><a href="/About/">About</a></span></div>
                        
                            <div class="None" ><span><a href="/My Project/">My Project</a></span></div>
                        
                    </section>
                    
                    <section>
                        
    <div class=" "><span><a href="/category/前端/">前端</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/JavaScript面试题/">JavaScript面试题</a></li><li class=""><a href="/archives/Promise异步调用/">Promise异步调用</a></li></ul></div><div class=" "><span><a href="/category/面试/">面试</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/面试题整理/">面试题整理</a></li><li class=""><a href="/archives/腾讯移动客户端面经/">腾讯移动客户端面经</a></li><li class=""><a href="/archives/计算机其它面试题/">计算机其它面试题</a></li><li class=""><a href="/archives/Mysql&Redis数据库面试题/">Mysql&Redis数据库面试题</a></li><li class=""><a href="/archives/Spring框架面试题/">Spring框架面试题</a></li><li class=""><a href="/archives/字节跳动面试/">字节跳动面试</a></li><li class=""><a href="/archives/后端面试题/">后端面试题</a></li></ul></div><div class=" "><span><a href="/category/数据库/">数据库</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Mysql面试题/">Mysql面试题</a></li><li class=""><a href="/archives/SQL实战题目/">SQL实战题目</a></li><div class=" "><span><a href="/category/Hadoop/">Hadoop</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Hadoop伪分布式配置/">Hadoop伪分布式配置</a></li></ul></div></ul></div><div class="open "><span><a href="/category/Spring/">Spring</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Spring面试题/">Spring面试题</a></li><li class="current"><a href="/archives/SpringMVC面试题/">SpringMVC面试题</a></li><div class=" "><span><a href="/category/SpringBoot/">SpringBoot</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/服务器上部署SpringBoot/">服务器上部署SpringBoot</a></li></ul></div><div class=" "><span><a href="/category/SpringCloud/">SpringCloud</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/认识SpringCloud/">认识SpringCloud</a></li></ul></div></ul></div><div class=" "><span><a href="/category/数据结构&算法/">数据结构&算法</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/数据结构&算法笔记/">数据结构&算法笔记</a></li><li class=""><a href="/archives/数据结构&算法题目合集/">数据结构&算法题目合集</a></li></ul></div><div class=" "><span><a href="/category/Java/">Java</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Java-JVM/">Java-JVM</a></li><li class=""><a href="/archives/Java-集合容器/">Java-集合容器</a></li><li class=""><a href="/archives/Java-多线程并发/">Java-多线程并发</a></li><li class=""><a href="/archives/Java-设计模式/">Java-设计模式</a></li><li class=""><a href="/archives/Java-方法汇总/">Java-方法汇总</a></li><li class=""><a href="/archives/Java-基础面试题/">Java-基础面试题</a></li><li class=""><a href="/archives/Java-基础知识笔记/">Java-基础知识笔记</a></li><li class=""><a href="/archives/Import-excel-to-mysql/">Import excel to mysql</a></li></ul></div><div class=" "><span><a href="/category/Linux/">Linux</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Linux常用命令/">Linux常用命令</a></li><li class=""><a href="/archives/xshell connect to Centos7 in VMware/">用xshell连接虚拟机中的Centos7</a></li><div class=" "><span><a href="/category/Docker/">Docker</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Docker:Install-software/">Docker:Install software</a></li><li class=""><a href="/archives/Docker-deployment/">Docker deployment</a></li></ul></div></ul></div><div class=" "><span><a href="/category/My Project/">My Project</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/MyProject-AttendanceMiniprogram/">实验室出入管理小程序</a></li><li class=""><a href="/archives/ActivitySystem/">Javaweb大学活动管理系统</a></li><li class=""><a href="/archives/MyProject-SupermarketSystem/">Java Swing-超市系统</a></li></ul></div><div class=" "><span><a href="/category/Other/">Other</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/大三下实训期末作业/">大三下实训期末作业</a></li><li class=""><a href="/archives/修改Host以访问Github/">修改Host以访问Github</a></li></ul></div><div class=" "><span><a href="/category/Notes/">Notes</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/软考软件设计师笔记/">软考软件设计师笔记</a></li></ul></div><div class=" "><span><a href="/category/Maverick/">Maverick</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/typography/">Hello World!</a></li></ul></div>

                    </section>
                    <section hidden class="sidebar-external-link">
                        
                            <div class="external"><span><a href="https://blog.lifeisgg.online">Blog</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://photos.lifeisgg.online">Photos</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://github.com/LifeAlsoIsGG">GitHub</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://twitter.com/LifeAlsoIsGG">Twitter</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                    </section>
                    <section class="maverick">
                        <div><span style="border: 1px solid #d4dadf;"><a href="https://github.com/AlanDecode/Maverick" target="_blank">Maverick & Kepler</a></span></div>
                    </section>
                </aside>
                <div id="content-wrapper">
                    <div id="content">
    <section>
        <h1 class="post-title">SpringMVC面试题</h1>
        <p class="post-meta">
            <time>September 15 2020</time>
            <span class="tags">
                
                <span>
                    <a href="/tag/Spring/">#Spring</a>
                </span>
                
                <span>
                    <a href="/tag/SpringMVC/">#SpringMVC</a>
                </span>
                
            </span>
        </p>
        <article class="yue"><h1>1. 什么是MVC</h1>
<p>MVC即<code>Model-View-Controller</code>，将应用按照<code>Model（模型）</code>、<code>View（视图）</code>、<code>Controller（控制）</code>这样的方式分离。把较为复杂的web应用分成逻辑清晰的几部分，基于请求驱动指的就是使用<code>请求-响应模型</code>。是为了简化开发，减少出错。还是为了组内开发人员之间的配合。总之就是一种分层工作的办法。</p>
<p><figure><img data-width="871" data-height="600" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/4b2af76e3e0e0d831744ca544c105296.png" alt="" /></figure></p>
<ul>
<li><code>视图(View)</code>：是应用程序中处理数据显示的部分，代表用户交互界面，对于Web应用来说，可以是HTML，也可能是jsp、XML和Applet等。一个应用可能有很多不同的视图，MVC设计模式对于视图的处理仅限于视图上数据的采集和处理，以及用户的请求，而不包括在视图上的业务流程的处理。业务流程的处理交予模型(Model)处理。</li>
<li><code>模型(Model)</code>：是应用程序中用于处理应用程序数据逻辑的部分，是业务的处理以及业务规则的制定。通常模型对象负责在数据库中存取数据模型接受视图请求的数据，并返回最终的处理结果。业务模型的设计是MVC最主要的核心。MVC设计模式告诉我们，把应用的模型按一定的规则抽取出来，抽取的层次很重要，抽象与具体不能隔得太远，也不能太近。MVC并没有提供模型的设计方法，而只是组织管理这些模型，以便于模型的重构和提高重用性。</li>
<li><code>控制(Controller)</code>：是应用程序中处理用户交互的部分，可以理解为从用户接收请求, 将模型与视图匹配在一起，共同完成用户的请求。划分控制层的作用也很明显，它清楚地告诉你，它就是一个分发器，选择什么样的模型，选择什么样的视图，可以完成什么样的用户请求。控制层并不做任何的数据处理。</li>
</ul>
<h1>2. 什么是MVP[Android]</h1>
<p>MVP即<code>Model-View-Presenter</code></p>
<p><figure><img data-width="871" data-height="601" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/792aa864d85a86b8c490d3f1b9c9afdd.png" alt="" /></figure></p>
<h1>3. MVC和MVP的区别</h1>
<p><figure><img data-width="1067" data-height="480" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/d64f90c57e6773cf89f190f99f251c7f.jpg" alt="" /></figure></p>
<p>MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller。</p>
<ul>
<li>Presenter与Controller都扮演了逻辑层的角色，但是Presenter层的功能相对更复杂，因为他负责和View的双向交互，Controller只是单向的中介。因为Presenter是从View层抽离出来的，通常和View是一对一的关系，而Controller是面向业务的，往往是单例模式或者提供静态方法。</li>
<li>MVP中View和Model是不能进行通信的，虽然加重了P层的负担，但是有利于维护View层和Model层，如果条件允许，我们还可以对Presenter进一步拆分，来弥补Presenter负担过重的问题。</li>
<li>MVC中View和Model层可以直接交互，虽然方便了两者之间的交互，但是耦合性相对较高。</li>
</ul>
<h1>4. 什么是SpringMVC</h1>
<p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把<code>模型(Model)</code>，<code>视图(View)</code>，<code>控制器(Controller)</code>分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。Spring MVC 下我们⼀般把后端项⽬分为 Service层 （处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台 ⻚⾯)。</p>
<h1>5. SpringMVC的优点</h1>
<ul>
<li>可以支持各种视图技术,而不仅仅局限于JSP；</li>
<li>与Spring框架集成（如IoC容器、AOP等）；</li>
<li>清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。</li>
<li>支持各种请求资源的映射策略。</li>
</ul>
<h1>6. SpringMVC组件</h1>
<ul>
<li><code>DispatcherServlet</code>：前端控制器。也称为中央控制器，它是整个请求响应的控制中心，组件的调用由它统一调度。有了他就减少了其他组件之间的耦合度。</li>
<li><code>HandlerMapping</code>：处理器映射器。它根据用户访问的 URL 映射到对应的后端处理器 Handler。也就是说它知道处理用户请求的后端处理器，但是它并不执行后端处理器，而是将处理器告诉给中央处理器。</li>
<li><code>HandlerAdapter</code>：处理器适配器。根据传过来不同类型的<code>Hadnle</code>它调用后端处理器中的方法，返回逻辑视图 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>。</li>
<li><code>ViewResolver</code>：视图解析器。将 <code>ModelAndView</code> 逻辑视图解析为具体的视图（如 JSP）。</li>
<li><code>Handler</code>：后端处理器。对用户具体请求进行处理，也就是我们编写的 <code>Controller</code> 类。需要程序员开发</li>
</ul>
<h1>7. SpringMVC工作流程</h1>
<p><figure><img data-width="1195" data-height="659" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/43a507768e3a02998c8e67620f7c1534.jpg" alt="" /></figure></p>
<ol>
<li>用户向服务端发送一次请求，这个请求会先到前端控制器<code>DispatcherServlet</code>(也叫中央控制器)。</li>
</ol>
<ol>
<li><code>DispatcherServlet</code>接收到请求后会调用<code>HandlerMapping</code>处理器映射器来，根据配置或注解获取不同的<code>Handle</code>，并返回给<code>DispatcherServlet</code>。由此得知，该请求该由哪个<code>Controller</code>来处理（并未调用Controller，只是得知）</li>
</ol>
<ol>
<li><code>DispatcherServlet</code>调用<code>HandlerAdapter</code>处理器适配器，告诉处理器适配器应该要去执行哪个<code>Controller</code></li>
</ol>
<ol>
<li><code>HandlerAdapter</code>处理器适配器去执行<code>Controller</code>并得到<code>ModelAndView</code>(数据和视图)，并层层返回给<code>DispatcherServlet</code></li>
</ol>
<ol>
<li><code>DispatcherServlet</code>将<code>ModelAndView</code>交给<code>ViewReslover</code>视图解析器解析，然后返回真正的视图<code>View</code>。</li>
</ol>
<ol>
<li><code>DispatcherServlet</code>将模型数据填充到视图中</li>
</ol>
<ol>
<li><code>DispatcherServlet</code>将结果响应给用户</li>
</ol>
<h1>SpringMVC注解原理</h1>
<p>注解本质是一个继承了 Annotation的特殊接口,其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时,返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法,会最终调用AnnotationInvocationHandler的 invoke方法。该方法会从 membervalues这个Map中索引出对应的值。而 membervalues的来源是Java常量池</p>
<p>​     Controller类使用继承@Component注解的方法，将其以单例的形式放入spring容器，如果仔细看的话会发现每个注解里面都有一个默认的value()方法，它的作用是为当前的注解声明一个名字，一般默认为类名，然后spring会通过配置文件中的context:component-scan的配置，进行如下操作：</p>
<ul>
<li>使用asm技术扫描.class文件，并将包含@Component及元注解为@Component的注解@Controller、@Service、@Repository或者其他自定义的的bean注册到beanFactory中，</li>
<li>然后spring在注册处理器</li>
<li>实例化处理器，然后将其放到beanPostFactory中，然后我们就可以在类中进行使用了。</li>
<li>创建bean时，会自动调用相应的处理器进行处理。</li>
</ul>
<h1>9. SpringMVC常用注解</h1>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.cnblogs.com/leskang/p/5445698.html">https://www.cnblogs.com/leskang/p/5445698.html</a></li>
</ul>
</blockquote>
<ul>
<li><p><strong>@Controller</strong></p>
<blockquote><p><code>@Controller</code>注解在类上，表明这个类是Spring MVC里的<code>Controller</code>，将其声明为Spring的一个Bean，<code>DispatchServlet</code>会自动扫描注解了此注解的类，并将Web请求映射到注解了<code>@RequestMapping</code>的方法上，需要注意的是，在Spring MVC声明控制器Bean的时候，只能使用@Controller。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>@RestController</strong></p>
<blockquote><p><code>@RestController</code>是一个组合注解，组合了<code>@Controller</code>和<code>@ResponseBody</code>，意味着当只开发一个和页面交互数据的控制的时候，需要使用此注解。 若没有此注解，要想实现上述功能，则需自己在代码中加<code>@Controller</code>和<code>@ResponseBody</code>两个注解。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>@RequestMapping</strong></p>
<blockquote><p><code>@RequestMapping</code>注解是用来映射Web请求（访问路径和参数）、处理类和方法的。它可以注解在类和方法上。注解在方法上的<code>@RequestMapping</code>路径会继承注解在类上的路径，<code>@RequestMapping</code>支持Servlet的request和response作为参数，也支持对它们的媒体类型进行配置。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>@ResponseBody</strong></p>
<blockquote><p><code>@ResponseBody</code>支持将返回值放在<code>response</code>体内，而不是返回一个页面。我们很多机遇<code>Ajax</code>的程序，可以以此注解返回数据而不是返回页面；此注解可以放在返回值或者方法上。</p>
</blockquote>
</li>
<li><p><strong>@RequestBody</strong></p>
<blockquote><p><code>@RequestBody</code>允许<code>request</code>的参数在<code>request</code>体中，而不是在直接链接在地址后面。此注解放在参数前。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>@PathVariable</strong></p>
<blockquote><p><code>@PathVariable</code> 用来接收路径参数，如<code>/news/001</code>,可接收001作为参数，此注解放置在参数前。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>@Resource和@Autowired</strong></p>
<blockquote><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>@Repository</strong></p>
<blockquote><p>用于注解dao层，在daoImpl类上面注解。</p>
</blockquote>
</li>
</ul>
<h2>8.1 @Controller控制器</h2>
<p>在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于<code>HttpServletRequest</code> 和<code>HttpServletResponse</code> 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p>
<p>@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。</p>
<h2>8.2 @RestController</h2>
<p>可以发现，<code>@RestController</code>注解里面包含了<code>@Controller</code>注解和@<code>ResponseBody</code>注解，<code>@ResponseBody</code> 注解是将返回的数据结构转换为 <code>JSON</code> 格式，所以说可以这么理解：@RestController = @Controller + @ResponseBody ，省了很多事，我们使用 @RestController 之后就不需要再使用 @Controller 了。</p>
<h2>8.3 @RequestMapping请求映射</h2>
<p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<code>@RequestMapping</code>注解是用来映射Web请求（访问路径和参数）、处理类和方法的。它可以注解在类和方法上。注解在方法上的<code>@RequestMapping</code>路径会继承注解在类上的路径，<code>@RequestMapping</code>支持Servlet的<code>request</code>和<code>response</code>作为参数，也支持对它们的媒体类型进行配置。</p>
<h3>属性</h3>
<ul>
<li><p>value， method</p>
<blockquote><ul>
<li>value：   指定请求的实际地址，指定的地址可以是URI Template 模式。value 可以省略不写</li>
<li>method： 指定请求的method类型， GET、POST、PUT、DELETE等；默认为GET。不用每次在 @RequestMapping 注解中加 method 属性来指定，上面的 GET 方式请求可以直接使用 @GetMapping("/get") 注解，效果一样。相应地，PUT 方式、POST 方式和 DELETE 方式对应的注解分别为 <code>@PutMapping</code>、<code>@PostMapping</code> 和 <code>DeleteMapping</code>。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p>consumes，produces</p>
<blockquote><ul>
<li>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</li>
<li>produces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；如 produces = “application/json; charset=UTF-8”</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p>params，headers</p>
<blockquote><ul>
<li>params： 指定request中必须包含某些参数值是，才让该方法处理。</li>
<li>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</li>
</ul>
</blockquote>
</li>
</ul>
<h2>8.4 @ResponseBody</h2>
<p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到<code>Response</code>对象的<code>body</code>数据区。</p>
<p>使用时机：返回的数据不是<code>html</code>标签的页面，而是其他某种格式的数据时（如<code>json</code>、<code>xml</code>等）使用；</p>
<h2>8.5 @RequestBody</h2>
<p>RequestBody 注解用于接收前端传来的实体，接收参数也是对应的实体，比如前端通过 JSON 提交传来两个参数 username 和 password，此时我们需要在后端封装一个实体来接收。在传递的参数比较多的情况下，使用 @RequestBody 接收会非常方便。</p>
<h2>8.6 @PathVariable</h2>
<p>@PathVariable 注解主要用来获取 URL 参数，Spring Boot 支持 Restfull 风格的 URL，比如一个 GET 请求携带一个参数 id，我们将 id 作为参数接收，可以使用 @PathVariable 注解。如下：</p>
<div class="highlight"><pre><span></span><span class="nd">@Controller</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestController</span> <span class="p">{</span>  
     <span class="nd">@RequestMapping</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s">&quot;/user/{userId}/roles/{roleId}&quot;</span><span class="p">,</span><span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="p">.</span><span class="na">GET</span><span class="p">)</span>  
     <span class="kd">public</span> <span class="n">String</span> <span class="nf">getLogin</span><span class="p">(</span><span class="nd">@PathVariable</span><span class="p">(</span><span class="s">&quot;userId&quot;</span><span class="p">)</span> <span class="n">String</span> <span class="n">userId</span><span class="p">,</span>  
         <span class="nd">@PathVariable</span><span class="p">(</span><span class="s">&quot;roleId&quot;</span><span class="p">)</span> <span class="n">String</span> <span class="n">roleId</span><span class="p">){</span>  
         <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;User Id : &quot;</span> <span class="o">+</span> <span class="n">userId</span><span class="p">);</span>  
         <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Role Id : &quot;</span> <span class="o">+</span> <span class="n">roleId</span><span class="p">);</span>  
         <span class="k">return</span> <span class="s">&quot;hello&quot;</span><span class="p">;</span>  
     <span class="p">}</span>  
     <span class="nd">@RequestMapping</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s">&quot;/product/{productId}&quot;</span><span class="p">,</span><span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="p">.</span><span class="na">GET</span><span class="p">)</span>  
     <span class="kd">public</span> <span class="n">String</span> <span class="nf">getProduct</span><span class="p">(</span><span class="nd">@PathVariable</span><span class="p">(</span><span class="s">&quot;productId&quot;</span><span class="p">)</span> <span class="n">String</span> <span class="n">productId</span><span class="p">){</span>  
           <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Product Id : &quot;</span> <span class="o">+</span> <span class="n">productId</span><span class="p">);</span>  
           <span class="k">return</span> <span class="s">&quot;hello&quot;</span><span class="p">;</span>  
     <span class="p">}</span>  
     <span class="nd">@RequestMapping</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s">&quot;/javabeat/{regexp1:[a-z-]+}&quot;</span><span class="p">,</span>  
           <span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="p">.</span><span class="na">GET</span><span class="p">)</span>  
     <span class="kd">public</span> <span class="n">String</span> <span class="nf">getRegExp</span><span class="p">(</span><span class="nd">@PathVariable</span><span class="p">(</span><span class="s">&quot;regexp1&quot;</span><span class="p">)</span> <span class="n">String</span> <span class="n">regexp1</span><span class="p">){</span>  
           <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;URI Part 1 : &quot;</span> <span class="o">+</span> <span class="n">regexp1</span><span class="p">);</span>  
           <span class="k">return</span> <span class="s">&quot;hello&quot;</span><span class="p">;</span>  
     <span class="p">}</span>  
<span class="p">}</span>
</pre></div>
<h2>8.7 @RequestParam</h2>
<p>@RequestParam 注解顾名思义，也是获取请求参数的，主要用于在SpringMVC后台控制层获取参数，类似一种request.getParameter("name")。上面我们介绍了 @PathValiable 注解也是获取请求参数的，那么 @RequestParam 和 @PathVariable 有什么不同呢：</p>
<p>@PathValiable 是从 URL 模板中获取参数值，类似Restfull</p>
<div class="highlight"><pre><span></span><span class="nl">http:</span><span class="c1">//localhost:8080/user/{id}</span>
</pre></div>
<p>@RequestParam 是从 Request 里获取参数值，即这种风格的 URL：</p>
<div class="highlight"><pre><span></span><span class="nl">http:</span><span class="c1">//localhost:8080/user?id=1</span>
</pre></div>
<h3>属性</h3>
<p>defaultValue = "0", required = false, value = "isApp"；</p>
<ul>
<li><strong>required</strong>：true 表示该参数必须要传，否则就会报 404 错误，false 表示可有可无。</li>
<li><strong>defaultValue</strong>：表示设置默认值</li>
<li><strong>value</strong>:值表示接受的传入的参数类型</li>
</ul>
<h2>8.8 @Resource和@Autowired</h2>
<p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p>
<h3>不同点</h3>
<p>@Resources按名字，是JDK的；@Autowired按类型，是Spring的。</p>
<ul>
<li>@Autowired注解是按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。</li>
<li>@Resource注解和@Autowired一样，也可以标注在字段或属性的setter方法上，但它默认按名称装配。名称可以通过@Resource的name属性指定，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。 </li>
</ul>
<h3>@Autowired</h3>
<p>@Autowired为Spring提供的注解，需要导入包<code>org.springframework.beans.factory.annotation.Autowired</code>;只按照byType注入。</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestServiceImpl</span> <span class="p">{</span>
    <span class="c1">// 下面两种@Autowired只要使用一种即可</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="n">UserDao</span> <span class="n">userDao</span><span class="p">;</span> <span class="c1">// 用于字段上</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUserDao</span><span class="p">(</span><span class="n">UserDao</span> <span class="n">userDao</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 用于属性的方法上</span>
        <span class="k">this</span><span class="p">.</span><span class="na">userDao</span> <span class="o">=</span> <span class="n">userDao</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h3>@Resource</h3>
<p>@Resource默认按照<code>ByName</code>自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：<code>name</code>和<code>type</code>，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestServiceImpl</span> <span class="p">{</span>
    <span class="c1">// 下面两种@Resource只要使用一种即可</span>
    <span class="nd">@Resource</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;userDao&quot;</span><span class="p">)</span>
    <span class="kd">private</span> <span class="n">UserDao</span> <span class="n">userDao</span><span class="p">;</span> <span class="c1">// 用于字段上</span>

    <span class="nd">@Resource</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;userDao&quot;</span><span class="p">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUserDao</span><span class="p">(</span><span class="n">UserDao</span> <span class="n">userDao</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 用于属性的setter方法上</span>
        <span class="k">this</span><span class="p">.</span><span class="na">userDao</span> <span class="o">=</span> <span class="n">userDao</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p>
<p>@Resource装配顺序：</p>
<ol>
<li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</li>
<li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</li>
<li>如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</li>
<li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</li>
</ol>
<p>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p>
<h1>9. Spring控制器是什么设计模式，有什么问题，为什么是这个模式</h1>
<p>是<strong>单例模式</strong>，所以在多线程访问的时候有线程安全问题不要用同步会影晌性能的。解决方案是在控制器里面不能写字段成员变量。使用单例模式是为了性能（无需频繁初始化），同时也没有必要使用多例模式。万一必须要定义一个非静态成员变量时候，则通过注解<code>@Scope("prototype")</code>，将其设置为多例模式</p>
</article>
    </section>

    
    <section id="content-pager">
        
            <div class="next">
                <a class="card" href="/archives/Spring面试题/">
                    <time>September 16 2020</time>
                    <span>Spring面试题</span>
                </a>
            </div>
        
        
            <div class="prev">
                <a class="card" href="/archives/SQL实战题目/">
                    <time>September 05 2020</time>
                    <span>SQL实战题目</span>
                </a>
            </div>
        
    </section>
    

    
        <section id="comments">
            <div id="vcomments"></div>
        </section>
        <script>
            window.ValineOpt = {"enable": true, "el": "#vcomments", "appId": "0j0KcckWXNcj4LM9RWVh1nKN-gzGzoHsz", "appKey": "TGMR5Eo0w2lsuE1wyO7p5cyv", "visitor": true, "recordIP": true, "placeholder": "\u8fd8\u8bf7\u4e0d\u541d\u8d50\u6559"};
            window.ValineOpt.path = window.location.pathname;
        </script>
    

    <script>
        document.body.classList.add('content');
        document.body.classList.remove('archive');
    </script>
</div>
                    <footer>
                        <span>Copyright © 2020 LifeAlsoIsGG</span>
                        
    <span class="leancloud_visitors"
            id="/archives/SpringMVC面试题/" 
            data-flag-title="SpringMVC面试题">
            <i class="fa fa-eye"></i> <i style="font-style: normal" class="leancloud-visitors-count"></i> Views
        </span>

                        <span class="addon">
<p><a href="http://www.beian.miit.gov.cn">粤ICP备19126168号</a>
</span>
                    </footer>
                </div>
                
<aside id="toc-container" class="no-scrollbar">
    <span><i class="fa fa-align-right"></i> CONTENTS</span>
    <div id="toc"></div>
</aside>

            </div>
        </main>


        <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/tocbot@4.10.0/dist/tocbot.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/assets/kepler-ef161b04d5.js"></script>
        <script>
            function ExSearchCall(item){
                if (item && item.length) {
                    $('.ins-close').click(); // 关闭搜索框
                    $('input.ins-search-input').val(''); // 清空
                    let url = item.attr('data-url'); // 获取目标页面 URL
                    $.pjax({url: url, 
                        container: '#pjax-container',
                        fragment: '#pjax-container',
                        timeout: 8000, }); // 发起一次 PJAX 请求
                }
            }
        </script>

        <!--Valine-->
        
            <script>
                var initValine = function () {
                    if (typeof window.ValineOpt === 'object' && $(window.ValineOpt.el).length) {
                        new Valine(window.ValineOpt);
                    }
                }
            </script>
            <script async src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js' onload="initValine()"></script>
        

        <!--ExSearch-->
        <script src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/assets/ExSearch/ExSearch-493cb9cd89.js"></script>
        
        <!--katex-->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/assets/katex.min.css">
        <script defer src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/assets/katex.min.js"></script>
        <script>
        mathOpts = {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "\\[", right: "\\]", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false}
            ]
        };
        </script>
        <script defer src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

        
    </body>
</html>