<!DOCTYPE HTML>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,LifeAlsoIsGG,Galileo,wiki" />
    <meta name="generator" content="Maverick 1.1" />
    <meta name="template" content="Kepler" />
    <link rel="alternate" type="application/rss+xml" title="LifeAlsoIsGG-Wiki &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="LifeAlsoIsGG-Wiki &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/assets/kepler-426969802d.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/assets/ExSearch/ExSearch-182e5a8868.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.10.0/dist/tocbot.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/789484ff62d43bd5733be3cdce42c1d1.json"
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function(){
            if(/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)){
                document.body.classList.add('safari')
            }else{
                document.body.classList.remove('safari')
            }
        });
    </script>
    
<title>Java-基础面试题 - LifeAlsoIsGG-Wiki</title>
<meta name="author" content="LifeAlsoIsGG" />
<meta name="description" content="Java基础面试题" />
<meta property="og:title" content="Java-基础面试题 - LifeAlsoIsGG-Wiki" />
<meta property="og:description" content="Java基础面试题" />
<meta property="og:site_name" content="LifeAlsoIsGG-Wiki" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/archives/Java-基础面试题/" />
<meta property="og:image" content="" />
<meta property="article:published_time" content="2020-08-08T23:24:32-00.00" />
<meta name="twitter:title" content="Java-基础面试题 - LifeAlsoIsGG-Wiki" />
<meta name="twitter:description" content="Java基础面试题" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="" />


    
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//cdn.jsdelivr.net" />
<link rel="icon" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/avatar.png" type="images/x-ico" />

    </head>
    
    <body class="content">
        <header>
            <div class="container">
                <section>
                    <a href="/"><img src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/avatar.png">LifeAlsoIsGG-Wiki</a>
                </section>
                <section>
                    <nav>
                        <ul>
                            
                                <li><a href="https://blog.lifeisgg.online" target="_blank">Blog</a></li>
                            
                                <li><a href="https://photos.lifeisgg.online" target="_blank">Photos</a></li>
                            
                                <li><a href="https://github.com/LifeAlsoIsGG" target="_blank">GitHub</a></li>
                            
                                <li><a href="https://twitter.com/LifeAlsoIsGG" target="_blank">Twitter</a></li>
                            
                        </ul>
                    </nav>
                </section>
    
                <section>
                    <a hidden class="toggle-toc" target="_self" href="javascript:void(0)" onclick="$(body).toggleClass('toc-open')"><i class="fa fa-align-right"></i></a>
                    <a hidden class="toggle-navbar" target="_self" href="javascript:void(0)" onclick="$(body).toggleClass('navbar-open')"><i class="fa fa-indent"></i></a>
                    <button class="search-form-input"><i class="fa fa-search"></i></button>
                </section>
            </div>
        </header>

        <main>
            <div id="pjax-container" class="container">
                <aside id="navbar" class="no-scrollbar">
                    
                    <section class="sidebar-nav">
                        
                            <div class="None" ><span><a href="/">Home</a></span></div>
                        
                            <div class="None" ><span><a href="/archives/">Archives</a></span></div>
                        
                            <div class="None" ><span><a href="/About/">About</a></span></div>
                        
                            <div class="None" ><span><a href="/My Project/">My Project</a></span></div>
                        
                    </section>
                    
                    <section>
                        
    <div class=" "><span><a href="/category/数据库/">数据库</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/SQL实战题目/">SQL实战题目</a></li><div class=" "><span><a href="/category/Mysql/">Mysql</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/uni-app/">uni-app</a></li></ul></div><div class=" "><span><a href="/category/Hadoop/">Hadoop</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Hadoop伪分布式配置/">Hadoop伪分布式配置</a></li></ul></div></ul></div><div class=" "><span><a href="/category/数据结构&算法/">数据结构&算法</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/数据结构&算法/">数据结构&算法</a></li><li class=""><a href="/archives/数据结构&算法题目合集/">数据结构&算法题目合集</a></li></ul></div><div class=" "><span><a href="/category/面试/">面试</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/腾讯移动客户端面经/">腾讯移动客户端面经</a></li><li class=""><a href="/archives/计算机其它面试题/">计算机其它面试题</a></li><li class=""><a href="/archives/Mysql&Redis数据库面试题/">Mysql&Redis数据库面试题</a></li><li class=""><a href="/archives/Spring框架面试题/">Spring框架面试题</a></li><li class=""><a href="/archives/字节跳动面试/">字节跳动面试</a></li><li class=""><a href="/archives/后端面试题/">后端面试题</a></li></ul></div><div class="open "><span><a href="/category/Java/">Java</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Java-JVM/">Java-JVM</a></li><li class=""><a href="/archives/Java-容器/">Java-容器</a></li><li class=""><a href="/archives/Java-多线程并发/">Java-多线程并发</a></li><li class=""><a href="/archives/Java-设计模式/">Java-设计模式</a></li><li class=""><a href="/archives/Java-方法汇总/">Java-方法汇总</a></li><li class="current"><a href="/archives/Java-基础面试题/">Java-基础面试题</a></li><li class=""><a href="/archives/Java-基础知识笔记/">Java-基础知识笔记</a></li><li class=""><a href="/archives/Import-excel-to-mysql/">Import excel to mysql</a></li></ul></div><div class=" "><span><a href="/category/Linux/">Linux</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Linux常用命令/">Linux常用命令</a></li><li class=""><a href="/archives/xshell connect to Centos7 in VMware/">用xshell连接虚拟机中的Centos7</a></li><div class=" "><span><a href="/category/Docker/">Docker</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Docker:Install-software/">Docker:Install software</a></li><li class=""><a href="/archives/Docker-deployment/">Docker deployment</a></li></ul></div></ul></div><div class=" "><span><a href="/category/My Project/">My Project</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/MyProject-AttendanceMiniprogram/">实验室出入管理小程序</a></li><li class=""><a href="/archives/ActivitySystem/">Javaweb大学活动管理系统</a></li><li class=""><a href="/archives/MyProject-SupermarketSystem/">Java Swing-超市系统</a></li></ul></div><div class=" "><span><a href="/category/JavaScript/">JavaScript</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/Promise异步调用/">Promise异步调用</a></li></ul></div><div class=" "><span><a href="/category/Vue/">Vue</a><button class="toggle_sidebar fa"></button></span><ul><div class=" "><span><a href="/category/uni-app/">uni-app</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/uni-app/">uni-app</a></li></ul></div></ul></div><div class=" "><span><a href="/category/Spring/">Spring</a><button class="toggle_sidebar fa"></button></span><ul><div class=" "><span><a href="/category/SpringBoot/">SpringBoot</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/服务器上部署SpringBoot/">服务器上部署SpringBoot</a></li></ul></div><div class=" "><span><a href="/category/SpringCloud/">SpringCloud</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/认识SpringCloud/">认识SpringCloud</a></li></ul></div></ul></div><div class=" "><span><a href="/category/Other/">Other</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/大三下实训期末作业/">大三下实训期末作业</a></li><li class=""><a href="/archives/修改Host以访问Github/">修改Host以访问Github</a></li></ul></div><div class=" "><span><a href="/category/Notes/">Notes</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/软考软件设计师笔记/">软考软件设计师笔记</a></li></ul></div><div class=" "><span><a href="/category/Maverick/">Maverick</a><button class="toggle_sidebar fa"></button></span><ul><li class=""><a href="/archives/typography/">Hello World!</a></li></ul></div>

                    </section>
                    <section hidden class="sidebar-external-link">
                        
                            <div class="external"><span><a href="https://blog.lifeisgg.online">Blog</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://photos.lifeisgg.online">Photos</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://github.com/LifeAlsoIsGG">GitHub</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                            <div class="external"><span><a href="https://twitter.com/LifeAlsoIsGG">Twitter</a><button class="go-external"><i class="fa fa-external-link"></i></button></span></div>
                        
                    </section>
                    <section class="maverick">
                        <div><span style="border: 1px solid #d4dadf;"><a href="https://github.com/AlanDecode/Maverick" target="_blank">Maverick & Kepler</a></span></div>
                    </section>
                </aside>
                <div id="content-wrapper">
                    <div id="content">
    <section>
        <h1 class="post-title">Java-基础面试题</h1>
        <p class="post-meta">
            <time>August 08 2020</time>
            <span class="tags">
                
                <span>
                    <a href="/tag/面试/">#面试</a>
                </span>
                
                <span>
                    <a href="/tag/Java/">#Java</a>
                </span>
                
            </span>
        </p>
        <article class="yue"><h1>学习路线</h1>
<p><figure><img data-width="628" data-height="808" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/f53560858e548e5859e3b095609cd821.png" alt="" /></figure></p>
<h1>JDK和JRE区别</h1>
<ul>
<li><strong><u>JDK（Java Development Kit）</u></strong>是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。</li>
<li><strong><u>Java Runtime Environment（JRE）</u></strong>是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。</li>
<li><strong><u>Java Virtual Machine（Java虚拟机JVM）</u></strong>的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。</li>
</ul>
<p><figure><img data-width="904" data-height="493" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/4be18fd971a5c330e26e143bddbe8542.png" alt="" /></figure></p>
<h2>JDK（Java Development Kit）</h2>
<ul>
<li>JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。</li>
<li>JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。</li>
</ul>
<p><strong>类型</strong></p>
<ul>
<li>SE(J2SE)，standard edition，标准版，是我们通常用的一个版本，从JDK 5.0开始，改名为Java SE。</li>
<li>EE(J2EE)，enterprise edition，企业版，使用这种JDK开发J2EE应用程序，从JDK 5.0开始，改名为Java EE。</li>
<li>ME(J2ME)，micro edition，主要用于移动设备、嵌入式设备上的java应用程序，从JDK 5.0开始，改名为Java ME。</li>
</ul>
<h2>JRE（Java Runtime Environment）</h2>
<p>​       是运行基于Java语言编写的程序所不可缺少的运行环境。RE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件。<strong>但是在运行编译好的程序中包含Servlet时，需要JDK</strong></p>
<h2>JVM（Java Virtual Machine）</h2>
<p>​       就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。</p>
<p>也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p>
<p>只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。</p>
<p>JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<h1>重载和重写</h1>
<h2>重载(Overload)</h2>
<ol>
<li>重载Overload是一个类中多态性的一种表现或者一个类中多个构造器的实现</li>
<li>重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)</li>
<li>重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</li>
</ol>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Father</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="n">Father</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Father</span><span class="p">();</span>
        <span class="n">s</span><span class="p">.</span><span class="na">sayHello</span><span class="p">();</span>
        <span class="n">s</span><span class="p">.</span><span class="na">sayHello</span><span class="p">(</span><span class="s">&quot;wintershii&quot;</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sayHello</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sayHello</span><span class="p">(</span><span class="n">String</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h2>重写(Override)</h2>
<ol>
<li><strong>发生在父类与子类之间</strong></li>
<li><strong>方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同</strong></li>
<li>访问修饰符的限制一定要<strong>大于</strong>被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)</li>
<li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li>
</ol>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Father</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="n">Son</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Son</span><span class="p">();</span>
        <span class="n">s</span><span class="p">.</span><span class="na">sayHello</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sayHello</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Son</span> <span class="kd">extends</span> <span class="n">Father</span><span class="p">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sayHello</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;hello by &quot;</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
<h2>重载（Overload）和重写（Override）的区别</h2>
<p>​       方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。</p>
<h1>构造器Constructor是否可被Override(重写)</h1>
<p>​       构造器Constructor不能被继承，因此不能被<strong>重写(Override)</strong>，但是可以被<strong>重载（Overload）</strong>。如果父类自定义了有参构造函数，则子类无论定义构造函数与否，定义有参构造函数与否，都会报错，正确的做法是在子类的构造方法中添上super（参数），以表明子类构造之前先构造父类，而这句话必须放在第一句，否则报"Constructor call must be the first statement in a constructor"的错误。</p>
<h2>类的加载顺序</h2>
<ol>
<li>父类的静态代码块/初始化静态变量（两者优先级相同）</li>
<li>执行子类的静态代码/初始化静态变量（两者优先级相同，谁写在前面谁先执行）</li>
<li>初始化父类成员变量/执行代码块{}（两者优先级相同），父类的构造器</li>
<li>子类的成员变量/代码块，最后子类的构造器。</li>
</ol>
<p>例如：</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="p">{</span>
    <span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">(</span><span class="s">&quot;Test&quot;</span><span class="p">);</span>
    <span class="kd">static</span><span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;test static&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="nf">Test</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;test constructor&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">new</span> <span class="n">MyClass</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Person</span><span class="p">{</span>
    <span class="kd">static</span><span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;person static&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="p">(</span><span class="n">String</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;person &quot;</span><span class="o">+</span><span class="n">str</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kd">class</span> <span class="nc">MyClass</span> <span class="kd">extends</span> <span class="n">Test</span> <span class="p">{</span>
    <span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">(</span><span class="s">&quot;MyClass&quot;</span><span class="p">);</span>
    <span class="kd">static</span><span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;myclass static&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="nf">MyClass</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;myclass constructor&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>结果：</p>
<blockquote><ul>
<li>test static</li>
<li>myclass static</li>
<li>person static</li>
<li>person Test</li>
<li>test constructor</li>
<li>person MyClass</li>
<li>myclass constructor</li>
</ul>
</blockquote>
<p>顺序解析：</p>
<blockquote><ul>
<li>首先加载Test类，因此会执行Test类中的static块。</li>
<li>接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。</li>
<li>在加载完之后，就通过构造器来生成对象。而在生成对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，</li>
<li>接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。</li>
</ul>
</blockquote>
<h1>三大特性封装继承多态</h1>
<p><figure><img data-width="672" data-height="519" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/580e90e67848582220c27c9295576f74.png" alt="" /></figure></p>
<h2>封装</h2>
<p>​       封装（Encapsulation）是面向对象方法的重要原则，就是把对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。实体类那些属性就是被封装</p>
<ul>
<li>将类的某些信息隐藏在类的内部，不允许外部程序进行直接的访问调用。</li>
<li>通过该类提供的方法来实现对隐藏信息的操作和访问。</li>
<li>隐藏对象的信息。</li>
<li>留出访问的对外接口。</li>
</ul>
<h2>继承</h2>
<p>​       继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。当然，如果在父类中拥有私有属性(private修饰)，则子类是不能被继承的。</p>
<p>只支持单继承，即一个子类只允许有一个父类，但是可以实现多级继承，及子类拥有唯一的父类，而父类还可以再继承。</p>
<ul>
<li>子类可以拥有父类的属性和方法。</li>
<li>子类可以拥有自己的属性和方法。</li>
<li>子类可以重写覆盖父类的方法。</li>
</ul>
<p><strong>使用</strong></p>
<p>在父子类关系继承中，如果成员变量重名，则创建子类对象时，访问有两种方式。</p>
<ul>
<li><p>直接通过子类对象访问成员变量</p>
<p>等号左边是谁，就优先使用谁，如果没有就向上找。</p>
</li>
<li><p>间接通过成员方法访问成员变量</p>
<p>该方法属于谁，谁就优先使用，如果没有就向上找。</p>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FU</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">numFU</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;父类成员变量：&quot;</span><span class="o">+</span><span class="n">numFU</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">methodFU</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;父类成员方法!&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Zi</span> <span class="kd">extends</span> <span class="n">FU</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">numZi</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;子类成员变量：&quot;</span><span class="o">+</span><span class="n">numFU</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">methodZi</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;子类方法！&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExtendDemo</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">FU</span> <span class="n">fu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FU</span><span class="p">();</span>
        <span class="c1">// 父类的实体对象只能调用父类的成员变量</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;父类：&quot;</span> <span class="o">+</span> <span class="n">fu</span><span class="p">.</span><span class="na">numFU</span><span class="p">);</span>   <span class="c1">// 结果：10</span>

        <span class="n">Zi</span> <span class="n">zi</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Zi</span><span class="p">();</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;调用父类：&quot;</span> <span class="o">+</span> <span class="n">zi</span><span class="p">.</span><span class="na">numFU</span><span class="p">);</span> <span class="c1">// 结果：10</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;子类：&quot;</span> <span class="o">+</span> <span class="n">zi</span><span class="p">.</span><span class="na">numZi</span><span class="p">);</span>   <span class="c1">// 结果：20</span>

        <span class="cm">/** 输出结果为200，证明在重名情况下，如果子类中存在则优先使用，</span>
<span class="cm">         *  如果不存在则去父类查找，但如果父类也没有那么编译期就会报错。</span>
<span class="cm">         */</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">zi</span><span class="p">.</span><span class="na">num</span><span class="p">);</span> <span class="c1">// 结果：200</span>
        <span class="cm">/**</span>
<span class="cm">         * 通过成员方法调用成员变量</span>
<span class="cm">         */</span>
        <span class="n">zi</span><span class="p">.</span><span class="na">method</span><span class="p">();</span>    <span class="c1">// 结果：10</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h2>多态</h2>
<p>指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p>
<p><strong>实现方式</strong></p>
<ul>
<li>接口多态性。</li>
<li>继承多态性。</li>
<li>通过抽象类实现的多态性。</li>
</ul>
<p><strong>向上转型</strong></p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MultiDemo</span> <span class="p">{</span>
       <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
           <span class="c1">// 多态的引用，就是向上转型，此时无法使用之类中父类没有的方法</span>
           <span class="n">Animals</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Dog</span><span class="p">();</span>
           <span class="n">dog</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span><span class="c1">//狗在吃骨头！</span>

           <span class="n">Animals</span> <span class="n">cat</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cat</span><span class="p">();</span>
           <span class="n">cat</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span><span class="c1">//猫在吃鱼！</span>

           <span class="c1">// 如果要调用父类中没有的方法，则要向下转型</span>
           <span class="n">Dog</span> <span class="n">dogDown</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dog</span><span class="p">)</span><span class="n">dog</span><span class="p">;</span>
           <span class="n">dogDown</span><span class="p">.</span><span class="na">watchDoor</span><span class="p">();</span>

       <span class="p">}</span>
   <span class="p">}</span>
   <span class="kd">class</span> <span class="nc">Animals</span> <span class="p">{</span>
       <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
           <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;动物吃饭！&quot;</span><span class="p">);</span>
       <span class="p">}</span>
   <span class="p">}</span>
   <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="n">Animals</span><span class="p">{</span>
       <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
           <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;狗在吃骨头！&quot;</span><span class="p">);</span>
       <span class="p">}</span>
       <span class="kd">public</span> <span class="kt">void</span> <span class="nf">watchDoor</span><span class="p">(){</span>
           <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;狗看门！&quot;</span><span class="p">);</span>
       <span class="p">}</span>
   <span class="p">}</span>
   <span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="n">Animals</span><span class="p">{</span>
       <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
           <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;猫在吃鱼！&quot;</span><span class="p">);</span>
       <span class="p">}</span>
   <span class="p">}</span>
</pre></div>
<p><figure><img data-width="1372" data-height="592" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/ae6316ac34c01a4db403e8e329d0425b.png" alt="" /></figure></p>
<h1>this | super | final | static关键字</h1>
<h2>this</h2>
<ul>
<li>本类成员方法中，访问<strong>本类</strong>的成员变量。</li>
<li>本类成员方法中，访问<strong>本类</strong>的另一个成员方法。</li>
<li>本类的构造方法中，访问<strong>本类</strong>的另一个构造方法。</li>
</ul>
<p><figure><img data-width="945" data-height="463" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/40b2317328456c1863313da7e6978822.png" alt="" /></figure></p>
<h2>super</h2>
<ul>
<li>子类的成员方法中，访问<strong>父类</strong>的成员变量。</li>
<li>子类的成员方法中，访问<strong>父类</strong>的成员方法。</li>
<li>子类的构造方法中，访问<strong>父类</strong>的构造方法。</li>
</ul>
<p><figure><img data-width="955" data-height="520" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/a330aabcdf7a7ff4e55e31c10bd850f5.png" alt="" /></figure></p>
<p><strong>注意</strong></p>
<ul>
<li>this关键字同super一样，必须在构造方法的第一个语句，且是唯一的。</li>
<li>this与super不能同时存在。</li>
</ul>
<h2>final</h2>
<p><figure><img data-width="792" data-height="440" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/766c6ad905f4ec524f79aa59c2c43ab7.png" alt="" /></figure></p>
<p><figure><img data-width="965" data-height="290" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/7dd5e7b872f9729d7ae35d638ef51504.png" alt="" /></figure></p>
<h2>static</h2>
<p><figure><img data-width="963" data-height="323" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/cadae2b13731450515c64ae27948c3aa.png" alt="" /></figure></p>
<h1>String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h1>
<h2>Java String 类：String字符串常量</h2>
<p>需要注意的是，String的值是不可变的，这就导致每次对String的操作都会生成<strong>新的String对象</strong>，这样不仅效率低下，而且大量浪费有限的内存空间。我们来看一下这张对String操作时内存变化的图：</p>
<p><figure><img data-width="723" data-height="231" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/5db91e25835b7dd1cd632f88792fef53.png" alt="" /></figure></p>
<p>我们可以看到，初始String值为“hello”，然后在这个字符串后面加上新的字符串“world”，这个过程是需要重新在栈堆内存中开辟内存空间的，最终得到了“hello world”字符串也相应的需要开辟内存空间，<strong>这样短短的两个字符串，却需要开辟三次内存空间</strong>，不得不说这是对内存空间的<strong>极大浪费</strong>。为了应对经常性的字符串相关的操作，就需要使用Java提供的其他两个操作字符串的类——StringBuffer类和StringBuild类来对此种变化字符串进行处理。</p>
<h2>StringBuffer 和 StringBuilder 类——StringBuffer、StringBuilder字符串变量</h2>
<p><figure><img data-width="669" data-height="378" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/6bdf860e2216af59b14ae4594a8a0deb.png" alt="" /></figure></p>
<p>当对字符串进行修改的时候，需要使用 <strong>StringBuffer(线程安全)</strong> 和 <strong>StringBuilder(线程不安全)</strong> 类。</p>
<p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 <strong>StringBuilder 的方法不是线程安全的（不能同步访问）</strong>。</p>
<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>
<p><figure><img data-width="472" data-height="417" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/b94c451ccb4f736feaff90f63a51a207.png" alt="" /></figure></p>
<h2>区别</h2>
<ul>
<li><strong>String：</strong>不可变字符串；</li>
<li><strong>StringBuffer：</strong>可变字符串、效率低、线程安全；</li>
<li><strong>StringBuilder：</strong>可变字符序列、效率高、线程不安全；</li>
</ul>
<p>初始化上的区别，String可以空赋值，后者不行，报错</p>
<p><figure><img data-width="676" data-height="256" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/9214ff2b052e94d8c8e37660994f0f72.png" alt="" /></figure></p>
<p><figure><img data-width="649" data-height="357" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/e25f12eec33e4be64109cf79ca7c881d.png" alt="" /></figure></p>
<h1>装箱与拆箱</h1>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html">https://www.cnblogs.com/dolphin0520/p/3780005.html</a></p>
<p><figure><img data-width="772" data-height="642" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/8e04b140daa6b856ac471baf41b1c76a.png" alt="" /></figure></p>
<p><figure><img data-width="966" data-height="555" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/3a6e33d9c72289d3ec40143f33783f76.png" alt="" /></figure></p>
<h2>面试题</h2>
<p><figure><img data-width="615" data-height="419" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/75b191b71b65866200fa95a5afe20899.png" alt="" /></figure></p>
<p>​       从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在<strong>[-128,127]</strong>之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p>
<p>​       上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。</p>
<p><figure><img data-width="614" data-height="379" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/a79e6e029a87f9038ee9acccdd072f9f.png" alt="" /></figure></p>
<p><figure><img data-width="639" data-height="94" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/33487f286e90e5b203b921404feb58d1.png" alt="" /></figure></p>
<h1>在 Java 中定义⼀个不做事且没有参数的构造⽅法的作⽤</h1>
<p>​       Java 程序在执⾏⼦类的构造⽅法之前，如果没有⽤ <strong>super()</strong> 来调⽤⽗类特定的构造⽅法，则会调⽤ <strong>⽗类中“没有参数的构造⽅法”</strong>。因此，如果⽗类中只定义了有参数的构造⽅法，⽽在⼦类的构造⽅法中 ⼜没有⽤ super() 来调⽤⽗类中特定的构造⽅法，则编译时将发⽣错误，因为 Java 程序在⽗类中找 不到没有参数的构造⽅法可供执⾏。解决办法是在⽗类⾥加上⼀个不做事且没有参数的构造⽅法。</p>
<h1>接⼝和抽象类</h1>
<p><figure><img data-width="787" data-height="745" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/9bb207522d74cb0da858e9a3b2296979.png" alt="" /></figure></p>
<p><figure><img data-width="649" data-height="468" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/80b193c34b2d086b4c16381827fdeeca.png" alt="" /></figure></p>
<p><figure><img data-width="726" data-height="188" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/739c48564080012e87baafaa27243d6b.png" alt="" /></figure></p>
<h1>成员变量与局部变量的区别有哪些？</h1>
<p><figure><img data-width="642" data-height="390" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/f41b5a00a488a5bb030e9936fb2c7510.png" alt="" /></figure></p>
<h1>静态⽅法和实例⽅法有何不同</h1>
<ul>
<li>在外部调用静态方法时，可以使用<strong>"类名.方法名"</strong>的方式，也可以使用<strong>"对象名.方法名"</strong>的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li>
</ul>
<h1>==与equals()</h1>
<p><figure><img data-width="656" data-height="928" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/1b7fb6fb30bcbab095fd074cea048bdc.png" alt="" /></figure></p>
<h1>hashcode()与equals()</h1>
<p>参考</p>
<blockquote><ul>
<li><a href="https://www.cnblogs.com/chenpi/p/5489494.html">equals()和hashCode()之间的关系</a></li>
<li><a href="https://www.cnblogs.com/skywang12345/p/3324958.html">https://www.cnblogs.com/skywang12345/p/3324958.html</a></li>
</ul>
</blockquote>
<h2>第一种 不会创建“类对应的散列表”</h2>
<h1>为什么 Java 中只有值传递？</h1>
<p>参考</p>
<blockquote><p><a href="https://blog.csdn.net/bjweimengshu/article/details/79799485">https://blog.csdn.net/bjweimengshu/article/details/79799485</a></p>
</blockquote>
<h1>Java中异常处理</h1>
<p>参考</p>
<blockquote><p><a href="https://blog.csdn.net/sugar_no1/article/details/88593255">https://blog.csdn.net/sugar_no1/article/details/88593255</a></p>
</blockquote>
<p><figure><img data-width="815" data-height="487" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/fd1c7b79705d7a588b9f41419e8f6376.png" alt="" /></figure></p>
<p><figure><img data-width="830" data-height="447" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/ca217f5fec24f2060b557cb55df73b94.png" alt="" /></figure></p>
<p><figure><img data-width="817" data-height="646" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/d81fe61de7d7ab0ebb567364d55ccb95.png" alt="" /></figure></p>
<p><figure><img data-width="829" data-height="411" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/633321d8b22037b633208d6babd81ef5.png" alt="" /></figure></p>
<h1>获取⽤键盘输⼊常⽤的两种⽅法</h1>
<p><figure><img data-width="811" data-height="339" src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/archives/assets/e2a1a62aa5dccc7e26e905dce17c3bcc.png" alt="" /></figure></p>
<h2>输入一个字符</h2>
<div class="highlight"><pre><span></span><span class="n">Scanner</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scanner</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">in</span><span class="p">);</span>
<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="na">next</span><span class="p">().</span><span class="na">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
<h2>next()和nextLine()</h2>
<ul>
<li><strong>next()：</strong>不可以读取空格。它不能读两个由空格或符号隔开的单词。此外，next()在读取输入后将光标放在同一行中。(next()只读空格之前的数据,并且光标指向本行)</li>
<li><strong>nextLine()：</strong>可以读取空格，包括单词之间的空格和除回车以外的所有符号(即。它读到行尾)。读取输入后，nextLine()将光标定位在下一行。</li>
</ul>
<h1>泛型使用</h1>
<p>参考</p>
<blockquote><p><a href="https://www.cnblogs.com/jpfss/p/9928747.html">https://www.cnblogs.com/jpfss/p/9928747.html</a></p>
</blockquote>
<h1>浅拷贝 | 深拷贝</h1>
<ul>
<li>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址</li>
<li>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存</li>
</ul>
<ol>
<li></li>
</ol>
<h1>String</h1>
<h2>创建的两种方式</h2>
<ul>
<li><p>第一种是通过<strong>“字面量”</strong>赋值</p>
<div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">str</span><span class="o">=</span><span class="s">&quot;hello&quot;</span>
</pre></div>
</li>
<li><p>第二种是通过<strong>new关键字创建新对象</strong>，在内存中用构造器创建新对象形式</p>
<div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">str</span><span class="o">=</span><span class="k">new</span> <span class="n">String</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
</pre></div>
</li>
</ul>
<p><strong>案例：</strong></p>
<div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;abcd&quot;</span><span class="p">;</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="s">&quot;abcd&quot;</span><span class="p">;</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// True</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">b</span><span class="p">));</span> <span class="c1">// True</span>
</pre></div>
<p>a==b为真，是因为a和b都指向了方法区里面的同一个字符串，引用值相等；</p>
<p>当相同的字符串被创建多次，内存中只保存一份字符串常量值，这就是字符串的"驻留"</p>
<p><strong>案例二：</strong></p>
<div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="p">(</span><span class="s">&quot;abcd&quot;</span><span class="p">);</span>
<span class="n">String</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="p">(</span><span class="s">&quot;abcd&quot;</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">d</span><span class="p">);</span> <span class="c1">// False</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">d</span><span class="p">));</span> <span class="c1">// True</span>
</pre></div>
<p>c==d 为假，是因为c和d引用了对内存中的两个不同的对象，不同的对象，引用值肯定不同</p>
</article>
    </section>

    
    <section id="content-pager">
        
            <div class="next">
                <a class="card" href="/archives/Spring框架面试题/">
                    <time>August 08 2020</time>
                    <span>Spring框架面试题</span>
                </a>
            </div>
        
        
            <div class="prev">
                <a class="card" href="/archives/Java-基础知识笔记/">
                    <time>August 08 2020</time>
                    <span>Java-基础知识笔记</span>
                </a>
            </div>
        
    </section>
    

    
        <section id="comments">
            <div id="vcomments"></div>
        </section>
        <script>
            window.ValineOpt = {"enable": true, "el": "#vcomments", "appId": "0j0KcckWXNcj4LM9RWVh1nKN-gzGzoHsz", "appKey": "TGMR5Eo0w2lsuE1wyO7p5cyv", "visitor": true, "recordIP": true, "placeholder": "\u8fd8\u8bf7\u4e0d\u541d\u8d50\u6559"};
            window.ValineOpt.path = window.location.pathname;
        </script>
    

    <script>
        document.body.classList.add('content');
        document.body.classList.remove('archive');
    </script>
</div>
                    <footer>
                        <span>Copyright © 2020 LifeAlsoIsGG</span>
                        
    <span class="leancloud_visitors"
            id="/archives/Java-基础面试题/" 
            data-flag-title="Java-基础面试题">
            <i class="fa fa-eye"></i> <i style="font-style: normal" class="leancloud-visitors-count"></i> Views
        </span>

                        <span class="addon">
<p><a href="http://www.beian.miit.gov.cn">粤ICP备19126168号</a>
</span>
                    </footer>
                </div>
                
<aside id="toc-container" class="no-scrollbar">
    <span><i class="fa fa-align-right"></i> CONTENTS</span>
    <div id="toc"></div>
</aside>

            </div>
        </main>


        <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/tocbot@4.10.0/dist/tocbot.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/assets/kepler-ef161b04d5.js"></script>
        <script>
            function ExSearchCall(item){
                if (item && item.length) {
                    $('.ins-close').click(); // 关闭搜索框
                    $('input.ins-search-input').val(''); // 清空
                    let url = item.attr('data-url'); // 获取目标页面 URL
                    $.pjax({url: url, 
                        container: '#pjax-container',
                        fragment: '#pjax-container',
                        timeout: 8000, }); // 发起一次 PJAX 请求
                }
            }
        </script>

        <!--Valine-->
        
            <script>
                var initValine = function () {
                    if (typeof window.ValineOpt === 'object' && $(window.ValineOpt.el).length) {
                        new Valine(window.ValineOpt);
                    }
                }
            </script>
            <script async src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js' onload="initValine()"></script>
        

        <!--ExSearch-->
        <script src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/assets/ExSearch/ExSearch-493cb9cd89.js"></script>
        
        <!--katex-->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/assets/katex.min.css">
        <script defer src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/assets/katex.min.js"></script>
        <script>
        mathOpts = {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "\\[", right: "\\]", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false}
            ]
        };
        </script>
        <script defer src="https://cdn.jsdelivr.net/gh/lifealsoisgg/Wiki@gh-pages/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

        
    </body>
</html>