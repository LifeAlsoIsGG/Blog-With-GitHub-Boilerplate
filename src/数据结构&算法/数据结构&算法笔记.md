---
layout: post
title: 数据结构&算法
slug: 数据结构&算法
date: 2020/08/08 12:42:14
status: publish
author: LifeAlsoIsGG
categories: 
  - 数据结构&算法
tags: 
  - 数据结构&算法
---





## 稀疏数组

**只适用于大部分元素为相同时，比如五子棋**

![](images/稀疏数组1.jpg)

**第一行记录总行和总列数和除0外有多少个非零数据，剩余的行则记录每个数据的位置和值**

![](images/稀疏数组2.jpg)

**etc:五子棋**

![](images/稀疏数组3.jpg)



**Java代码**

```java
public class SparseArray {
    public static void main(String[] args) {
        /*0：没有棋子，1：表示黑子，2：表示白子*/
        int chessArr[][] = new int[11][11];
        chessArr[1][2] = 1;
        chessArr[2][4] = 2;
        chessArr[3][8] = 10;
//        输出原始为二维数组
        System.out.println("原始二维数组");
        for(int[] row : chessArr){
            for(int data: row){
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }

//        将二维数组转为稀疏数组
//        1.先遍历二维数组非0的个数
        int sum = 0;
        for(int i = 0; i < 11;i++){
            for(int j = 0; j < 11;j++){
                if(chessArr[i][j] != 0){
                    sum++;
                }
            }
        }

        System.out.println("非0个数为"+sum);

//        2.创建相应的稀疏数组
        int sparseArr[][] = new int[sum+1][3];
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;

//        遍历二维数组，将非0的值存放到sparseArr中
        int count = 0;
        for(int i = 0; i < 11; i++){
            for(int j = 0; j < 11; j++){
                if(chessArr[i][j] != 0){
                    count++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArr[i][j];
                }
            }
        }

//        输出稀疏数组
        System.out.println();
        System.out.println("稀疏数组");
        for(int[] row : sparseArr){
            for(int data: row){
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }

//        3.将稀疏数组转换为二维数组
//        声明数组
        int chessArry2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];

        for(int i  = 1; i < sparseArr.length; i++){
            chessArry2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }

        //        输出转换后的二维数组
        System.out.println("转换后的二维数组");
        for(int[] row : chessArr){
            for(int data: row){
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }
    }

}
```



**运行结果**

![](images/稀疏数组运行结果.jpg)





## 队列

先进先出



### 用数组模拟队列实现



- 队列本身是`有序列表`,若使用数组的结构来存储队列的数据,则队列数组的声明如下图,其中**`maxSize`**是该队列的最大容量 
- 因为队列的输出、翰入是分别从前后端来处理,因此需要两个变量 `front` 及rear分别记录队列前后端的下标,front会随着数据输出而改变,而rear则是随着数据输入而改变,如图所示:  



将数据存入队列时称为**<u>addQueue</u>**,**<u>addQueue</u>**需要两个步骤

- 将尾指针往后移：rear+1，判断队列满时的条件为当**front == rear**时为空
- 若尾指针rear小于队列的最大下标 maxSize-1,则将数据存入rear所指的数组元素中,否则无法存入数据。rear == maxSize-1时【队列满】  



![](images/队列.jpg)