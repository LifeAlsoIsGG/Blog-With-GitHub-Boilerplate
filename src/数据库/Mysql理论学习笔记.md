---
layout: post
title: Mysql理论学习笔记
slug: Mysql理论学习笔记
date: 2020/09/16 18:10:26
status: publish
author: LifeAlsoIsGG
categories: 
  - 数据库
tags: 
  - 数据库
  - Mysql
---





# 参考





# 存储引擎





## 查看MySQL提供的所有存储引擎

```sql
mysql> show engines;
```

![](images/Mysql理论学习笔记/mysql引擎.jpg)

从上图我们可以查看出 MySQL 当前默认的存储引擎是`InnoDB`,并且在5.7版本所有的存储引擎中只有 `InnoDB` 是事务性存储引擎，也就是说只有 InnoDB ⽀持事务。





## 查看MySQL当前默认的存储引擎

我们也可以通过下⾯的命令查看默认的存储引擎。

```sql
mysql> show variables like '%storage_engine%';
```



查看表的存储引擎

```sql
show table status like "table_name" ;
```





## InnoDB四大特性

参考

> - https://www.cnblogs.com/zhs0/p/10528520.html



- 插入缓冲( insert buffer)
- 二次写( double write)
- 自适应哈希索引（hash）
- 预读( read ahead  ）





## MyISAM和InnoDB区别



1. **是否⽀持⾏级锁** : MyISAM 只有表级锁(table-level locking)，⽽InnoDB ⽀持⾏级锁(rowlevel locking)和表级锁,默认为⾏级锁。
2. **是否⽀持事务和崩溃后的安全恢复**： MyISAM 强调的是性能，每次查询具有原⼦性,其执⾏速度 ⽐InnoDB类型更快，但是不提供事务⽀持。但是InnoDB 提供事务⽀持事务，外部键等⾼级数据 库功能。 具有`事务(commit)`、`回滚(rollback)`和`崩溃修复能⼒(crash recovery capabilities)` 的`事务安全(transaction-safe (ACID compliant))`型表。
3. **是否⽀持外键**： MyISAM不⽀持，⽽InnoDB⽀持。
4. **索引区别**：`InnoDB是聚集索引`，使用B+Tree作为索引结构，`数据文件是和（主键）索引绑在一起的`（表数据文件本身就是按B+Tree组织的一个索引结构），**必须要有主键**，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。`MyISAM是非聚集索引`，也是使用B+Tree作为索引结构，`索引和数据文件是分离的`，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
5. **表行数计算**：InnoDB不保存表的具体行数，执行select count(\*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；
6. **是否⽀持MVCC** ：仅 InnoDB ⽀持。应对⾼并发事务, MVCC⽐单纯的加锁更⾼效;MVCC只在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下⼯作;MVCC可以使⽤ `乐观 (optimistic)锁` 和 `悲观(pessimistic)锁`来实现;各数据库中MVCC实现并不统⼀



## 如何选择



1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；

2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。

3. 系统奔溃后，MyISAM恢复起来更困难，能否接受；





# 索引

MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。

打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。

拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。

索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。

创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。

实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。

上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。

建立索引会占用磁盘空间的索引文件。





## 缺点

- **时间方面**：创建索引和维护索引要耗费时间,具体地,当对表中的数据进行增加、删除和修改的时候,索引也要动态的维护,会降低增/改/删的执行效率
- **空间方面**：索引需要占物理空间





## 种类

| 名称       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 唯一索引   | 不允许有俩行具有相同的值，允许空值                           |
| 主键索引   | 为了保持数据库表与表之间的关系，不允许空值                   |
| 聚集索引   | 表中行的物理顺序与键值的逻辑(索引)顺序相同                   |
| 非聚集索引 | 聚集索引和非聚集索引的根本区别是**表记录的排列顺序和与索引的排列顺序是否一致** |
| 复合索引   | 在创建索引时,并不是只能对一列进行创建索引,可以与主键样,讲多个组合为索引 |
| 全文索引   | 全文索引为在字符串数据中进行复杂的词搜索提供有效支持         |





## 主键索引与唯一索引区别



回归到主键本身的特点

1. 主键是一种约束,唯一索引是一种索引,两者在本质上是不同的
2. 主键创建后一定包含一个唯一性索引,唯一性索引并不一定就是主键。
3. 唯一性索引列允许空值,而主键列不允许为空值。  
4. 主键列在创建时,已经默认为空值++唯一索引了。
5. 一个表最多只能创建一个主键,但可以创建多个唯一索引。
6. 主键更适合那些不容易更改的唯一标识,如自动递增列、身份证号等。
7. 主键可以被其他表引用为外键,而唯一索引不能





## 使用场景



1. 当数据多且字段值有相同的值得时候用普通索引
2. 当字段多且字段值没有重复的时候用唯一索引
3. 当有多个字段名都经常被查询的话用复合索引
4. 普通索引不支持空值,唯一索引支持空值。
5. 但是,若是这张表增删改多而查询较少的话,就不要创建索引了,因为如果
6. 你绐一列创建了索引,那么对该列进行增删改的时候,都会先访问这一列的索引,
7. 若是增,则在这一列的索引内以新填入的这个字段名的值为名创建索引的子
8. 若是改,则会把原来的删掉,再添入一个以这个字段名的新值为名创建索引的子集
9. 若是删,则会把索引中以这个字段为名的索引的子集删掉
10. 所以,会对增删改的执行减缓速度
11. 所以,若是这张表增删改多而查询较少的话,就不要创建索引了。
12. 更新太频繁地字段不适合创建索引
13. 不会出现在 where条件中的字段不该建立索引  





## 数据结构：B数索引 | 哈希索引

MySQL索引使⽤的数据结构主要有`BTree索引` 和 `哈希索引` 。对于哈希索引来说，底层的数据结构就是 哈希表，因此在绝⼤多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余⼤部分 场景，建议选择BTree索引。



### BTree索引



**B-树：**

![](images/Mysql理论学习笔记/B-树.png)

一个节点大小限制在`16k`



**B+树：**

![](images/Mysql理论学习笔记/B+树.png)







**B+树的特征：**

1. 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

2. 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接，方便区间查找。

3. 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。



**B+树的优势：**

1. 单一节点存储更多的元素，使得查询的IO次数更少。

2. 所有查询都要查找到叶子节点，查询性能稳定。

3. 所有叶子节点形成有序链表，便于区间范围查询。



MySQL的BTree索引使⽤的是B树中的B+Tree，但对于主要的两种存储引擎的实现⽅式是不同的。 







MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，⾸先按照B+Tree 搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址 读取相应的数据记录。这被称为“⾮聚簇索引”。 

InnoDB: 其数据⽂件本身就是索引⽂件。相⽐MyISAM，索引⽂件和数据⽂件是分离的，其表数据 ⽂件本身就是按B+Tree组织的⼀个索引结构，树的叶节点data域保存了完整的数据记录。这个索 引的key是数据表的主键，因此InnoDB表数据⽂件本身就是主索引。这被称为“聚簇索引（或聚集 索引）”。⽽其余的索引都作为ᬀ助索引，ᬀ助索引的data域存储相应记录主键的值⽽不是地 址，这也是和MyISAM不同的地⽅。在根据主索引搜索时，直接找到key所在的节点即可取出数 据；在根据辅助索引查找时，则需要先取出主键的值，再⾛⼀遍主索引。 因此，在设计表的时 候，不建议使⽤过⻓的字段作为主键，也不建议使⽤⾮单调的字段作为主键，这样会造成主索引 频繁分裂。 PS：整理⾃《Java⼯程师修炼之道》



### 哈希索引





# 锁



# 三大范式

参考

> - https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html



| 名称         | 描述                                                    |
| ------------ | ------------------------------------------------------- |
| **第一范式** | 据库表中的所有字段值都是不可分解的原子值                |
| **第二范式** | 满足第一范式且确保表中的每列都和主键相关                |
| **第三范式** | 满足第二范式且确保每列都和主键列直接相关,而不是间接相关 |



## 第一范式

第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。



![](images/Mysql理论学习笔记/第一范式.png)



## 第二范式

第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。所以有时候需要`中间映射表`

比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。

![](images/Mysql理论学习笔记/第二范式_1.png)



这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。**这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关**。所以在这里违反了第二范式的设计原则。

而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。



![](images/Mysql理论学习笔记/第二范式_2.png)



## 第三范式

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。



![](images/Mysql理论学习笔记/第三范式.png)



再例如，学生选课表，不能把课程的具体信息列放在此表中，应该多开一个表为课程信息表，然后两个表通过课程id映射。